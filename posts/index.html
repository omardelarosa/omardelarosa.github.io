<!DOCTYPE html>
<html>
  <head>
    <title>posts | omardelarosa.com</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="description" content="omar delarosa's website">
    <meta name="author" content="omardelarosa">
    <meta name="og:site_name" content="omar delarosa's website">
    <meta name="og:image" content="https://omardelarosa.com/assets/images/og-image.png">
    <meta name="og:url" content="https://omardelarosa.com/pages/posts/">
    <meta name="og:title" content="posts | omardelarosa.com">
    <meta name="og:type" content="article:section">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata:700|Press+Start+2P|Roboto:400,400i,700" rel="stylesheet">
  <link href="../dist/blog.css" rel="stylesheet"><link href="../dist/app.css" rel="stylesheet"></head>
  <body role="document">
    <div id="header-container"></div>
    <div id="main-container">
      <div id="background-container"></div>
      <div id="content-container">
        <div class="breadcrumbs-container">
          <ul class="breadcrumbs">
            <li class="breadcrumbs__item">&gt; </li>
            <li class="breadcrumbs__item"><a class="breadcrumbs__item--link" href="/">~</a></li>
            <li class="breadcrumbs__item"><span class="breadcrumbs__item--no-link">Posts</span>
            </li>
          </ul>
        </div>
        <h1 class="section-heading">Posts</h1>
        <div class="posts">
          <ul class="posts__list">
            <li class="posts__list__item">
              <div class="post__container">
                <h1 class="post__title"><a class="post__title--link" href="/posts/static-hosting-saga-2.html" id="static-hosting-saga-2">Simple HTTPS Setup S3 + CloudFlare</a></h1>
                <div class="post__meta"><span class="post__author"><a class="post__author--link" href="/pages/bio.html">omardelarosa</a></span><span class="post__published">November 29th 2017, 11:48:01 am</span></div>
                <div class="post__body"><p>After a bit more investigation yesterday, I realized that github pages forces my website headers to always be 30x.  This is not ideal. Furthermore, it makes it tough to use <code>https</code> protocol for my custom domain, which <a href="https://thenextweb.com/google/2015/12/17/unsecured-websites-are-about-to-get-hammered-in-googles-search-ranking/">google now favors in search results.</a></p>
<p>Thought I was never one to fully <a href="http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html">blog like a hacker</a>, I&#39;m now even closer to that hacker-blogging destiny by hosting this page via S3 + CloudFront.  Without going too deep into the &quot;why&quot;, I think with the limited time available for personal projects the low devops-y maintenance overhead for using static files instead of WordPress or fancy CMS is the main appeal.</p>
<h2 id="the-steps">The Steps</h2>
<p>Turns out, this process of getting your static hosting to be HTTPS ready, S3-hosted and search-friendly isn&#39;t as painful (or costly) as I&#39;d previously imagined.  Here&#39;s the gist:</p>
<h3 id="1-register-a-domain-">1. Register a domain.</h3>
<p>For this, I used Google Domains, which I&#39;ve gradually been moving all my domains to.  Nothing against, GoDaddy and IWantMyName.com (my former domain management systems), but their UIs are clunky and always trying to sell me more domains.  I wanted something simple an Google Domains delivers.</p>
<h3 id="2-make-an-s3-bucket">2. Make an S3 Bucket</h3>
<p>You can read about <a href="http://docs.aws.amazon.com/AmazonS3/latest/user-guide/create-bucket.html">the Amazon S3 bucket-making process elsewhere</a>.  The only caveat is to make sure that your bucket name matches your domain.  For example mine is: <code>omardelarosa.com</code>.  You will also need a second bucket to redirect the <code>www</code>.  For me its <code>www.omardelarosa</code>.  This is because of a small, quirk re: AWS S3 which is that CNAME redirects require the domain and bucket name to match.  I&#39;m guessing that&#39;s for security purposes.</p>
<h3 id="3-use-awscli-to-sync-up">3. Use <code>awscli</code> to Sync Up</h3>
<p>Anyway, once it&#39;s made, I recommend using the <code>awscli</code> to sync up your files, which looks like this:</p>
<pre><code class="lang-bash">pip <span class="hljs-keyword">install</span> awscli
cd /<span class="hljs-keyword">path</span>/<span class="hljs-keyword">to</span>/your/<span class="hljs-keyword">project</span>
aws configure
aws s3 <span class="hljs-keyword">sync</span> . s3://yoursite.com/
</code></pre>
<p>This will transfer all your files from the current directory to your bucket.  In my case, I exclude a few files like <code>node_modules/</code> and <code>.git/</code>, but use your own judgement.  This is kinda up to you.  Here&#39;s what I&#39;m using:</p>
<pre><code class="lang-bash"><span class="hljs-symbol">aws</span> <span class="hljs-built_in">s3</span> sync . <span class="hljs-built_in">s3</span>://omardelarosa.com/ --exclude <span class="hljs-string">"node_modules/*"</span> --exclude <span class="hljs-string">".*"</span>
</code></pre>
<h3 id="4-update-s3-file-permissions">4. Update S3 File permissions</h3>
<p>You will need to then make an files, directories public on S3 in order to allow browsers to load the files:</p>
<p><img src="/assets/uploads/2017_11_29_screenshot1.png" width="250" /></p>
<h3 id="5-configure-the-bucket-for-webhosting">5. Configure The Bucket for WebHosting</h3>
<p>You will then need to configure the S3 Bucket for Web Hosting, which is best explained by <a href="http://docs.aws.amazon.com/AmazonS3/latest/user-guide/static-website-hosting.html">Amazon&#39;s own docs on the subject of enabling web hosting</a>.</p>
<p>After this is done, you should be able to visit your website using the raw, AWS S3 bucket hostname:</p>
<pre><code>{yoursite-bucket}.s3-website-{yourawsregion}<span class="hljs-selector-class">.amazonaws</span><span class="hljs-selector-class">.com</span>
</code></pre><h3 id="6-sign-up-for-a-free-cloudflare-account">6. Sign Up For A Free CloudFlare Account</h3>
<p>Go to: <a href="https://www.cloudflare.com/a/sign-up">https://www.cloudflare.com/a/sign-up</a> and sign up.  (No, I don&#39;t get commission or affiliates.  It&#39;s just got a pretty usable free-tier.)</p>
<p>When this is done, make sure you configure the same domain you registered in step 1 to use CloudFlare&#39;s services, making sure to update your nameservers, etc. to theirs.</p>
<h3 id="7-ssl">7. SSL</h3>
<p>To enable SSL, just find the &quot;Crypto&quot; section in the CloudFlare Dashboard and set the SSL option to &quot;Flexible&quot;:</p>
<p><img src="/assets/uploads/2017_11_29_screenshot2.png" width="250" /></p>
<h3 id="8-https">8. HTTPS</h3>
<p>Finally, to enable HTTPS you will simply need to add a page rule for your domain that enforces HTTPS.  You can see the steps for doing this here on the <a href="https://support.cloudflare.com/hc/en-us/articles/200170536-How-do-I-redirect-all-visitors-to-HTTPS-SSL-">CloudFlare documentation for adding HTTPS</a>.</p>
<h3 id="9-adding-a-www-redirect">9. Adding a <code>www</code> redirect</h3>
<p>Once those steps are complete, if you would like to add a <code>www</code> redirect.  This can be done fairly simply by adding another S3 bucket called <code>www.{yoursitebucket-name}</code> and setting its redirect to your other bucket.  Instructions for that can be found on the <a href="http://docs.aws.amazon.com/AmazonS3/latest/user-guide/redirect-website-requests.html">AWS Docs for redirects.</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Once all these steps are done, you should have a fully functioning HTTPS static site hosted on S3 and backed (and cached) by CloudFlare.</p>
<p>After doing all this, I set up a few helpful scripts to &quot;deploy&quot; my site.  That script can be found <a href="https://github.com/omardelarosa/omardelarosa.github.io/blob/master/deploy.sh">here on the Github repo for this site.</a>.</p>
<p>In that script I also purge the cache after publishing and send the sitemap to Google.</p>
</div>
              </div>
            </li>
            <li class="posts__list__item">
              <div class="post__container">
                <h1 class="post__title"><a class="post__title--link" href="/posts/cloudflare-vs-zeit.html" id="cloudflare-vs-zeit">Static Hosting Updates 1</a></h1>
                <div class="post__meta"><span class="post__author"><a class="post__author--link" href="/pages/bio.html">omardelarosa</a></span><span class="post__published">November 28th 2017, 11:02:58 am</span></div>
                <div class="post__body"><p>So during this past Thanksgiving holiday, about the only time of year I sit down and work on personal projects these days, I went to go write a blog post and noticed that this site was down and probably had been for a while. Seems like when I switched over to using <a href="zeit.co/now">Zeit Now</a> over GH Pages for easier DNS management, etc, my last deployment failed.  However, I didn&#39;t immediately notice and so I guess the site had been down since at least 2 months ago.</p>
<p>I spent this morning getting it back up and running and moved it off Zeit and back to GH Pages.  Sadly, I lost some of the HTTPS features that Zeit had to automatically manage the domains etc.  The only advantage I had by using Zeit was easier HTTPS setup, but I quickly realized that CloudFlare&#39;s free tier is pretty much just as a robust and even adds a lot more controls.  Thanks to <a href="https://gist.github.com/cvan">cvan</a> on Github, I found <a href="https://gist.github.com/cvan/8630f847f579f90e0c014dc5199c337b">this really nice Gist that explains the process</a>.</p>
</div>
              </div>
            </li>
            <li class="posts__list__item">
              <div class="post__container">
                <h1 class="post__title"><a class="post__title--link" href="/posts/discovered-gem-pipe-dream.html" id="discovered-gem-pipe-dream">Discovered Gem - Pipe Dream</a></h1>
                <div class="post__meta"><span class="post__author"><a class="post__author--link" href="/pages/bio.html">omardelarosa</a></span><span class="post__published">February 25th 2017, 1:45:48 pm</span></div>
                <div class="post__body"><p>My primary mode of listening to music these days is <a href="https://www.spotify.com/us/discoverweekly/">Spotify&#39;s Discovered Weekly</a>.  Although I&#39;ve historically prefered &quot;manually curated&quot; music recommendation ala <a href="https://www.pitchfork.com">Pitchfork</a>, <a href="https://noisey.vice.com">Noisey</a>, <a href="http://www.brooklynvegan.com">Brooklyn Vegan</a>, etc., I haven&#39;t had as much time as I used to for reading those sites.  </p>
<p>Anyway, this will be the first of my <em>Discovered Gems</em> post that attempts to keep track of greak music I&#39;ve discovered via programmatic playlists (ala Discover Weekly).  The first song I care to share in this vain is:</p>
<h3 id="-pipe-dream-by-kyle-duke-the-brown-bag-boys">&quot;Pipe Dream&quot; by Kyle Duke &amp; The Brown Bag Boys</h3>
<iframe width="560" height="315" src="https://www.youtube.com/embed/MFUmt6F44cc" frameborder="0" allowfullscreen></iframe>

<p>As a great, woozy, hazy, quasi-lo-fi rock track, it&#39;s right up the alley of anyone who loves Real Estate or Mac DeMarco (like this guy).  The lyrics are also circular, simple and sparse.  A song that tries without trying.</p>
</div>
              </div>
            </li>
            <li class="posts__list__item">
              <div class="post__container">
                <h1 class="post__title"><a class="post__title--link" href="/posts/gpt-and-react.html" id="gpt-and-react">Google Publisher Tags and React Playing in Harmony</a></h1>
                <div class="post__meta"><span class="post__author"><a class="post__author--link" href="/pages/bio.html">omardelarosa</a></span><span class="post__published">February 22nd 2017, 10:33:51 pm</span></div>
                <div class="post__body"><h1 id="doing-google-publisher-tags-the-react-way">Doing Google Publisher Tags the React Way</h1>
<p>For all the wonders Webpack and Babel have brought to Front-End JavaScript, the modern, modular applications you build with those tools don&#39;t play well with third-party, drop-this-JavaScript-snippet-in-the-head-tag libraries.</p>
<p>For example, <a href="https://developers.google.com/doubleclick-gpt/reference">Google Publisher Tag (aka GPT)</a> has a great API and lots of clear documentation.  Unfortunately, they expect something clunky and external to your nice, modern bundled ES2017 application.  They expect something like this at the top of your markup:</p>
<pre><code class="lang-html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span>=<span class="hljs-string">"async"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.googletagservices.com/tag/js/gpt.js"</span>&gt;</span><span class="undefined">
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
      <span class="hljs-keyword">var</span> googletag = googletag || </span></span><span class="hljs-template-variable">{}</span><span class="xml"><span class="undefined">;
      googletag.cmd = googletag.cmd || [];
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'root'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
</code></pre>
<p>Meanwhile, the rest of your modern, modular, ES2017 application code looks like a jumble of <code>() =&gt; {}</code> Arrow Functions, <code>class</code> keywords, <code>const</code> and <code>let</code> and <code>import</code> and <code>...</code> and... you get the idea.</p>
<p>By comparison, GPT&#39;s closure-y architecture feels retro.</p>
<h2 id="reconciling-retro-libraries-with-modern-application-code">Reconciling Retro Libraries with Modern Application Code</h2>
<p>Alright, so very recently, I was working on a project in which I needed to fix a race condition between GPT and a React component.  What would happen was that React would render the DOM (including all the ad containers), fire all their respective component-lifecycle events before GPT was ready.</p>
<p>After treading water and pulling my hair out for hours, I stumbled upon a very simple way to keep everything in sync.</p>
<p>First, you need do load GPT in your head tag.  Duh:</p>
<pre><code class="lang-javascript">var googletag = googletag <span class="hljs-string">|| {};</span>
googletag.cmd = googletag.cmd <span class="hljs-string">|| [];</span>
</code></pre>
<p>Now you can let the <code>&lt;script async=&quot;async&quot; src=&quot;https://www.googletagservices.com/tag/js/gpt.js&quot;&gt;</code> take its sweet time loading, because you have that handy-dandy <code>cmd</code> <code>Array</code>.</p>
<p>According to <a href="https://developers.google.com/doubleclick-gpt/common_implementation_mistakes">this one Google article about avoiding implementation mistakes</a>, this handy <code>cmd</code> <code>Array</code> can be your best friend.</p>
<p>Assuming a <code>React</code> situation kinda of like this:</p>
<pre><code class="lang-jsx">
<span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, { <span class="hljs-type">Component</span> } from <span class="hljs-symbol">'reac</span>t';
<span class="hljs-keyword">import</span> { render } from <span class="hljs-symbol">'react</span>-dom';

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdUnit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

    componentDidMount() {
        <span class="hljs-keyword">this</span>.beginGPTsetup();
    }

    beginGPTSetup = () =&gt; {
        <span class="hljs-comment">// Begin GPT slot rendering, etc.    </span>
    }

    render() {
        <span class="hljs-keyword">return</span> (
            &lt;div id=<span class="hljs-symbol">'ad</span>-selector-abc'&gt;&lt;/div&gt;
        );
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (
            &lt;div&gt;
                &lt;h1&gt;<span class="hljs-type">My</span> <span class="hljs-type">Application</span> <span class="hljs-type">Heading</span>&lt;/h1&gt;
                &lt;div&gt;<span class="hljs-type">Content</span> <span class="hljs-type">Fragment</span> <span class="hljs-number">1</span>&lt;/div&gt;
                &lt;<span class="hljs-type">AdUnit</span> /&gt;
                &lt;div&gt;<span class="hljs-type">Content</span> <span class="hljs-type">Fragment</span> <span class="hljs-number">2</span>&lt;/div&gt;
            &lt;div&gt;
        )
  }
}

render(&lt;<span class="hljs-type">App</span> /&gt;, document.getElementById(<span class="hljs-symbol">'roo</span>t'));
</code></pre>
<p>As much as you can control what happens <em>inside</em> You can never really guarantee that GPT will be ready and fully loaded by the time your <code>&lt;App /&gt;</code> goes to render the <code>&lt;AdUnit /&gt;</code>.</p>
<p>However, with a few modifications, you can use React&#39;s own <code>state</code> to control your timing and avoid race conditions.</p>
<p>Let&#39;s add a few lifecycle methods to the <code>App</code> component:</p>
<pre><code class="lang-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    <span class="hljs-comment">// Create an initial state.</span>
    state = {
        <span class="hljs-comment">// Ensure that the GPTHasLoaded boolean is false</span>
        <span class="hljs-type">GPTHasLoaded</span>: <span class="hljs-literal">false</span>
    }

    componentWillMount() {
        <span class="hljs-comment">// Let's destructure the cmd array out of GPT.</span>
        const { googletag: { cmd }} = window;

        <span class="hljs-comment">// Feel free to get really paranoid here and check for Array-ness, too.</span>
        <span class="hljs-keyword">if</span> (cmd) {
            <span class="hljs-comment">// Enqueue a function onto GPT</span>
            cmd.push(() =&gt; <span class="hljs-keyword">this</span>.setState({ <span class="hljs-type">GPTHasLoaded</span>: <span class="hljs-literal">true</span> });
        }
    }

    render() {
        <span class="hljs-comment">// Reference the GPT boolean here.</span>
        const { state: { <span class="hljs-type">GPTHasLoaded</span> }} = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">return</span> (
            &lt;div&gt;
                &lt;h1&gt;<span class="hljs-type">My</span> <span class="hljs-type">Application</span> <span class="hljs-type">Heading</span>&lt;/h1&gt;
                &lt;div&gt;<span class="hljs-type">Content</span> <span class="hljs-type">Fragment</span> <span class="hljs-number">1</span>&lt;/div&gt;
                { <span class="hljs-type">GPTHasLoaded</span> &amp;&amp; &lt;<span class="hljs-type">AdUnit</span> /&gt; }
                &lt;div&gt;<span class="hljs-type">Content</span> <span class="hljs-type">Fragment</span> <span class="hljs-number">2</span>&lt;/div&gt;
            &lt;div&gt;
        )
  }
}
</code></pre>
<p>And voila!  Now React&#39;s own lifecycle methods will take care of avoiding race conditions.</p>
<p>The secret lies in how this little guy:</p>
<pre><code class="lang-javascript">cmd.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.setState({ GPTHasLoaded: <span class="hljs-literal">true</span> });
</code></pre>
<p>Kind of combines the best of both GPT and React in one little lambda callback of goodness.</p>
<p>Because googletag&#39;s <code>cmd</code> queue is automatically picked up once GPT is ready, it will process your <code>setState</code> if and only if GPT has loaded.  Or in their words:</p>
<blockquote>
<p>googletag.cmd maintains a list of commands that will be run as soon as GPT is ready. This is the correct way to make sure your callback is run when GPT has loaded.</p>
</blockquote>
<p>This avoids using any event-listeners or clumsy <code>googletag.apiReady</code> checks or <code>scriptEl.onload = function () {}</code>-style callbacks.</p>
<p>Instead, you let <code>React</code> be <code>React</code> and <code>GPT</code> be <code>GPT</code>.  A shiny, new modern library working in tandem with a semi-retro, closure-y one.</p>
<p>[ Insert GIF of React logo shaking hands with Google For Publishers Logo Here ]</p>
</div>
              </div>
            </li>
            <li class="posts__list__item">
              <div class="post__container">
                <h1 class="post__title"><a class="post__title--link" href="/posts/making-a-markdown-blog-using-webpack.html" id="making-a-markdown-blog-using-webpack">Making a Markdown Blog Using Webpack</a></h1>
                <div class="post__meta"><span class="post__author"><a class="post__author--link" href="/pages/bio.html">omardelarosa</a></span><span class="post__published">January 3rd 2017, 11:31:09 pm</span></div>
                <div class="post__body"><h2 id="a-brief-background">A Brief Background</h2>
<p>When I started working on this site, my first hunch was to use that <a href="https://jekyllrb.com/">classic static website builder, Jekyll</a>.  It&#39;s simplicity and tight github integration seemed great.  However, there&#39;s just one issue:  it&#39;s not easily integrated with <a href="https://webpack.github.io/">Webpack</a> and the rest of the modern front-end dev stack.  In fact, it seems written for Ruby on Rails devs--but let&#39;s save that for another post.</p>
<p>Shortly after starting to look beyond Jekyll, I started fiddling around with the <a href="https://github.com/ampedandwired/html-webpack-plugin"><code>html-webpack-plugin</code></a> and realized:  wait a minute I think I can make a perfectly suitable blog with just this.</p>
<h2 id="configuring-webpack">Configuring Webpack</h2>
<p>So if you&#39;re not already familiar with webpack, it relies on a <code>webpack.config.js</code> (or whatever you wanna name it) file that usually takes a form along the lines of:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// Your precompiled JS file(s) for bundling.</span>
    entry: {
        <span class="hljs-comment">// A main entry bundle.</span>
        main: <span class="hljs-string">'./src/main.js'</span>,
        <span class="hljs-comment">// Some other random bundle.</span>
        secondary: <span class="hljs-string">'./src/something-else.js'</span>
    },

    <span class="hljs-comment">// Your post-compiled assets path.</span>
    output: path.join(__dirname, <span class="hljs-string">'dist'</span>),

    <span class="hljs-comment">// Your module-loading configuration.</span>
    <span class="hljs-keyword">module</span>: {

        <span class="hljs-comment">// Loader/transpiler config.</span>
        loaders: [
            <span class="hljs-comment">// A sample babel loader that processes your fancy, ES2019-next-rc-11 or whatever.</span>
            {
              test: <span class="hljs-regexp">/\.js$/</span>, loader: <span class="hljs-string">'babel'</span>
            }
        ]
    },

    <span class="hljs-comment">// And this mysterious array.</span>
    plugins: [

        <span class="hljs-comment">// Why am I here??????</span>

    ]
};
</code></pre>
<p>Well the bulk of this file doesn&#39;t need much changing.  In fact, you can leave most of it as is.  The part that matters is that ever-so-mysterious <code>Array</code> of <code>plugins</code>.</p>
<h2 id="plugins-for-plugins-">Plugins for <code>plugins</code></h2>
<p>So for starters, let&#39;s come back to the <a href="https://github.com/ampedandwired/html-webpack-plugin"><code>html-webpack-plugin</code></a>.  If you aren&#39;t familiar with what it does, here&#39;s what it does:</p>
<ol>
<li>Injests an <code>Object</code> of options, such as <code>title</code>, metadata etc.</li>
<li>Injects the proper <code>&lt;link&gt;</code> and/or <code>&lt;script&gt;</code> tags associated with your webpack bundle.</li>
<li>Spits out a <code>.html</code> file based on your options.</li>
</ol>
<p>So given a template like this:</p>
<pre><code class="lang-jade"><span class="hljs-selector-tag">html</span>
  head
    title= htmlWebpackPlugin<span class="hljs-selector-class">.options</span><span class="hljs-selector-class">.title</span> 
    meta(charset=<span class="hljs-string">'utf-8'</span>)
  <span class="hljs-selector-tag">body</span>
    <span class="hljs-selector-id">#main-container</span> Hello world!
</code></pre>
<p>And a <code>webpack.config.js</code> (using <a href="https://pugjs.org/api/getting-started.html"><code>pug</code></a> for templates) that looks something like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = require(<span class="hljs-string">'html-webpack-plugin'</span>);

<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = {
    <span class="hljs-comment">// ...</span>

    plugins: [
        <span class="hljs-keyword">new</span> HtmlWebpackPlugin({
            <span class="hljs-comment">// A string identifying where the template is located.</span>
            <span class="hljs-comment">// and optionally which webpack loaders to use. </span>
            template: <span class="hljs-string">'pug!templates/index.pug'</span>,

            <span class="hljs-comment">// Do you wanna make some cache? $$$</span>
            cache: <span class="hljs-keyword">true</span>,

            <span class="hljs-comment">// Specifying that only the "main" bundle should be inserted.</span>
            chunks: [ <span class="hljs-string">'main'</span> ],

            <span class="hljs-comment">// The contents of your &lt;title&gt;&lt;/title&gt; tag.</span>
            title: <span class="hljs-string">'The Main Page'</span>,

            <span class="hljs-comment">// The location and source of your output file.</span>
            filename: <span class="hljs-string">'pages/index.html'</span>
        })
    ]

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Sounds pretty simple right?  It&#39;s deceptively simple.  Like webpack itself, this plugin&#39;s <a href="https://www.youtube.com/watch?v=4anAwXYqLG8">minimal API surface area</a> is where its power lies--and also in its ability to receive (and potentially render) arbitrary options.</p>
<h2 id="arbitrary-options-and-loops">Arbitrary Options and Loops</h2>
<p>The secret to making a blog from all this is is learning to combine two features of the <code>html-webpack-plugin</code>:</p>
<ol>
<li>The fact that you can pass as many of them as you want.</li>
<li>The arbitrary options object.</li>
</ol>
<p>So feature #1 is best harnessed with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">the <code>Array</code> spread operator</a> which is available in most post-ES6 flavors of JavaScript:</p>
<pre><code class="lang-javascript">const arr = [ ...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ], ...[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] ];
</code></pre>
<p><em>NOTE: For the remainder of this process, I recommend a relatively modern version of NodeJS (I&#39;m using 6.5.0 at the time of writing this).</em></p>
<p>Given the above <code>webpack.config.js</code>, you can create a bunch of HTML pages simply by list generation and iteration.  Here&#39;s an example using <a href="https://lodash.com/docs/4.17.4#times"><code>lodash.times</code></a>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);
<span class="hljs-comment">// https://lodash.com/docs/4.17.4#times</span>
<span class="hljs-keyword">const</span> times = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash/times'</span>);

<span class="hljs-keyword">const</span> makeHtmlConfig = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> ({
    <span class="hljs-attr">template</span>: <span class="hljs-string">'pug!templates/index.pug'</span>,
    <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">chunks</span>: [ <span class="hljs-string">'main'</span> ],
    <span class="hljs-attr">title</span>: <span class="hljs-string">`Page Number <span class="hljs-subst">${n}</span>`</span>,
    <span class="hljs-attr">filename</span>: <span class="hljs-string">`pages/page_<span class="hljs-subst">${n}</span>.html`</span>
});

<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// ...</span>

    plugins: [
        <span class="hljs-comment">// Instead of one HtmlWebpackPlugin, how about a hundred?</span>
        ...times(<span class="hljs-number">100</span>, makeHtmlConfig)
    ]

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>The above code should spit out 100 pages based on your <code>pug</code> template, each with a different <code>&lt;title&gt;&lt;/title&gt;</code> and filename.</p>
<p>That&#39;s obviously pretty useless.  However, by harnessing feature #2 from the list above, you can do some useful stuff.</p>
<h2 id="injecting-arbitrary-html-in-a-template">Injecting Arbitrary HTML In A Template</h2>
<p>Because <code>html-webpack-plugin</code> takes an plain <code>Object</code> as its input, you can add additional key/value pairs very easily using our above looping system.  However, the nicest part of all is that this data is all available inside the template from the <code>htmlWebpackPlugin.options</code> object.  (Along with a few others outlined in <a href="https://github.com/ampedandwired/html-webpack-plugin#writing-your-own-templates">its documention</a>).</p>
<p>So if I were to add the following changes to my <code>makeHtmlConfig</code> function:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> makeHtmlConfig = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> ({
    <span class="hljs-attr">template</span>: <span class="hljs-string">'pug!templates/index.pug'</span>,
    <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">chunks</span>: [ <span class="hljs-string">'main'</span> ],
    <span class="hljs-attr">title</span>: <span class="hljs-string">`Page Number <span class="hljs-subst">${n}</span>`</span>,
    <span class="hljs-attr">filename</span>: <span class="hljs-string">`pages/page_<span class="hljs-subst">${n}</span>.html`</span>,
    <span class="hljs-attr">bodyText</span>: <span class="hljs-string">`The number is <span class="hljs-subst">${n}</span>`</span>
});
</code></pre>
<p>And make the following changes to my source template:</p>
<pre><code class="lang-jade"><span class="hljs-selector-tag">html</span>
  head
    title= htmlWebpackPlugin<span class="hljs-selector-class">.options</span><span class="hljs-selector-class">.title</span> 
    meta(charset=<span class="hljs-string">'utf-8'</span>)
  <span class="hljs-selector-tag">body</span>
    #main-container= htmlWebpackPlugin<span class="hljs-selector-class">.options</span><span class="hljs-selector-class">.bodyText</span>
</code></pre>
<p>It would create a bunch of HTML pages with <code>&lt;div&gt;</code> elements in their <code>&lt;body&gt;</code> node&#39;s taking the following form:</p>
<pre><code class="lang-html">// pages/page_1.html
&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">'main-container'</span>&gt;The <span class="hljs-built_in">number</span> is <span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;
<span class="hljs-comment">
// pages/page_2.html</span>
&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">'main-container'</span>&gt;The <span class="hljs-built_in">number</span> is <span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;
<span class="hljs-comment">
// pages/page_3.html</span>
&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">'main-container'</span>&gt;The <span class="hljs-built_in">number</span> is <span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;
</code></pre>
<p>This alone a blog does not make, though.</p>
<h2 id="adding-markdown">Adding Markdown</h2>
<p>Now adding markdown is one of the easier parts.  To do this, just add several markdown files in the <code>./md</code> directory.</p>
<p>Then make the following modifications to the <code>webpack.config.js</code> file:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);
<span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">'marked'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// Assuming I add a bunch of .md files in my ./md dir.</span>
<span class="hljs-keyword">const</span> MARKDOWN_FILE_DIR = <span class="hljs-string">'./md'</span>;

<span class="hljs-comment">/*
* Generates an Array with the following data:
* [
*   { 
*     filename: '{markdownFilename}.md',
*     markdown: '{ markdownString }`
*   }
* ]
*/</span>
<span class="hljs-keyword">const</span> markdownFilesData = fs
   <span class="hljs-comment">// Read directory contents</span>
    .readdirSync(MARKDOWN_FILE_DIR)
    <span class="hljs-comment">// Take only .md files</span>
    .filter(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> /\.md$/.test(filename))
    <span class="hljs-comment">// Normalize file data.</span>
    .map(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">markdown</span>: fs.readFileSync(
              path.join(MARKDOWN_FILE_DIR, mdFilename)
            ),
            filename 
        }
    });

<span class="hljs-keyword">const</span> makeHtmlConfig = <span class="hljs-function">(<span class="hljs-params">{ filename, markdown }</span>) =&gt;</span> ({
    <span class="hljs-attr">template</span>: <span class="hljs-string">'pug!templates/index.pug'</span>,
    <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">chunks</span>: [ <span class="hljs-string">'main'</span> ],
    <span class="hljs-attr">title</span>: <span class="hljs-string">`Page Number <span class="hljs-subst">${n}</span>`</span>,
    <span class="hljs-attr">filename</span>: <span class="hljs-string">`pages/<span class="hljs-subst">${filename}</span>.html`</span>,
    <span class="hljs-comment">// Parses the markdown string and converts to HTML string</span>
    bodyHTML: marked(markdown)
});

<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// ...</span>

    plugins: [
        <span class="hljs-comment">// map the above function to the array of file data</span>
        ...markdownFiles.map(makeHtmlConfig)
    ]

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Afterwards, let&#39;s make a simple modifcation to the <code>pug</code> template to allow it to receive the HTML produced with the previous process and render the unescaped HTML string in the <code>div.#main-container</code>:</p>
<pre><code class="lang-jade"><span class="hljs-selector-tag">html</span>
  head
    title= htmlWebpackPlugin<span class="hljs-selector-class">.options</span><span class="hljs-selector-class">.title</span> 
    meta(charset=<span class="hljs-string">'utf-8'</span>)
  <span class="hljs-selector-tag">body</span>
    #main-container= !{htmlWebpackPlugin<span class="hljs-selector-class">.options</span><span class="hljs-selector-class">.bodyHTML</span>}
</code></pre>
<p>And voila!  You should now be able to add posts in Markdown to the <code>md/</code> directory and build the blog into static HTML pages using:</p>
<pre><code class="lang-shell">$ webpack --config webpack<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>
</code></pre>
<h2 id="examples">Examples</h2>
<p>To see a working example of this, just check out the following files in the source code of this very website:</p>
<ul>
<li><a href="https://github.com/omardelarosa/omardelarosa.github.io/blob/master/build/base.webpack.config.js"><code>build/base.webpack.config.js</code></a></li>
<li><a href="https://github.com/omardelarosa/omardelarosa.github.io/blob/master/build/prod.webpack.config.js"><code>build/prod.webpack.config.js</code></a> </li>
<li><a href="https://github.com/omardelarosa/omardelarosa.github.io/tree/master/_posts"><code>_posts/</code></a></li>
<li><a href="https://github.com/omardelarosa/omardelarosa.github.io/tree/master/posts"><code>posts/</code></a></li>
<li><a href="https://github.com/omardelarosa/omardelarosa.github.io/blob/master/templates/blog.pug"><code>templates/blog.pug</code></a></li>
</ul>
<p>Although there are a couple other things going on in the webpack configs for this project (such as a distinction between static <code>pages</code> and <code>posts</code>), the principles are basically the same as the above examples.</p>
</div>
              </div>
            </li>
            <li class="posts__list__item">
              <div class="post__container">
                <h1 class="post__title"><a class="post__title--link" href="/posts/new-blog.html" id="new-blog">A New Way of Blogging</a></h1>
                <div class="post__meta"><span class="post__author"><a class="post__author--link" href="/pages/bio.html">omardelarosa</a></span><span class="post__published">January 2nd 2017, 6:12:59 pm</span></div>
                <div class="post__body"><p>It&#39;s been a while since I wrote a blog post.  Why?  Well on the one hand, I&#39;ve had a shortage of free time.  On the other, I&#39;ve spent way too much time configuring and dealing with <a href="http://omardelarosa.tumblr.com">random</a> <a href="http://blog.omardelarosa.com">blogging</a> platforms  without really getting the things I want out of them:</p>
<ol>
<li>The ability to write in Markdown.</li>
<li>Simple syntax highlighting for code.</li>
<li>Manage my own post data using the file system.</li>
<li>Use modern web development tools to build.</li>
<li>Easy to publish from a bash terminal.</li>
</ol>
<p>These factors have made blogging just not feel very fun to me over the past few years.  However, over this past winter holiday, I decided to spend a few of my vacation days building my own platform with all of the above features.  </p>
<p>This very post is in fact, <a href="http://github.com/omardelarosa/omardelarosa.github.io/blob/master/_posts/1483396849251_new-blog.md">written in pure markdown</a>.  It also supports:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> msgArray = [
    <span class="hljs-string">'easy'</span>, <span class="hljs-string">'syntax'</span>, <span class="hljs-string">'highlighting'</span>
].<span class="hljs-keyword">join</span>(<span class="hljs-string">' '</span>);
</code></pre>
<p>As for the data itself, the entire system doesn&#39;t require databases or a backend.  It uses the file system and compiles markdown (as well as ES6, stylus, etc.) to plain static assets using modern build tools like webpack.</p>
<p>Best of all, I can publish from the terminal with a simple:</p>
<pre><code class="lang-bash"><span class="hljs-string">$ </span>npm run build
<span class="hljs-string">$ </span>git commit -m <span class="hljs-comment">"Added a new post!"</span>
<span class="hljs-string">$ </span>git push origin master
</code></pre>
<p>So yeah, this new website is still a work in progress, but more posts and updates to come.</p>
</div>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div id="footer"></div>
    <script src="/assets/js/ga.js"></script>
    <script src="/assets/js/fb.js"></script>
  <script type="text/javascript" src="../dist/blog.js"></script><script type="text/javascript" src="../dist/app.js"></script></body>
</html>